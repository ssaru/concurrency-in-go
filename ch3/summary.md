# 2020-06-25, Concurrency in Go, 21~48p

## 동시성 프로그래밍의 탄생 배경

-   무어법칙을 따라서 성능을 올리려다보니 단일 CPU의 성능 한계에 직면
-   이를 극복하기 위해서 멀티코어가 탄생함
-   멀티코어를 최대한 사용하기 위해서 병렬프로그래밍의 개념을 사용했지만, `지나치게 병렬적인 연산`을 제외하고는 순차적인 코드가 일부 섞인 동시성 코드가 탄생함
-   동시성 코드는 암달의 법칙을 따르며, 순차적인 코드에 성능 영향을 크게 받음
-   암달의 법칙에 의거해서 성능을 극대화하기 위해서 동시성 프로그래밍 잘할 수 있어야함

## 동시성 프로그래밍의 어려움

-   공유 메모리 사용으로 인해 레이스 컨디션이 발생함
-   이를 극복하기 위해 원자성(atomic)을 도입 -> 원자성의 개념은 굉장히 까다로운 개념인데, 스코프 컨텍스트에 따라 원자성의 적용범위가 달라질 수 있음(하드웨어 레벨 / 코드 레벨 / 시스템 레벨 등등)
-   원자성을 달성하기 위해 메모리 접근 동기화 기법을 사용(mutex, etc)
-   메모리 접근 동기화 기법을 사용하다보니 1). 데드락, 2) 라이브락, 3) 기아 상태라는 3가지 문제에 직면함
-   데드락이 발생하는 조건을 코프만이 정리함(코프만 조건). 이는 데드락의 탐지/예방/교정에 도움이 됨
-   기아상태(라이브락은 기아상태의 부분 집합;subset)를 탐지하기 위한 metric은 굉장히 중요한 요소가 될 수 있으나, 이 metric을 설정하는 것은 어려움
-   동시성의 안정성을 판단하는 것이 어려운 이유는 시스템적인 컨텍스트/주체/책임을 어떻게 정의하냐에 따라서 달라지기 때문
-   동시성의 안정성 판단의 어려움은 개인이 개발하는 영역에서 팀단위로 확장되었을 때, 더 심각한 문제를 초래함(주석을 잘 달자는 언급이 있네요 ㅎㅎ)
-   Golang에서는 이를 해소할 수 있는 도구들을 충분히 제공하며 책에서 어떤 순서로 다룰 지 소개할 예정. (go routine, channel)

## Note

-   코드를 따라 읽어가면서 약간의 부담이 있었습니다. 대략적인 내용은 이해가 됬는데.... golang 열심히 공부하면서 봐야겠네요 ㅎㅎ

# GO 동시성 프로그래밍, 2020-07-05, 65~85p

-   고루틴은 다른 코드와 함께 동시에 실행되는 함수 (병렬은 아니다)
-   고루틴은 OS스레드나 그린 스레드가 아니다.
-   고루틴은 코루틴이라는 높은 수준의 추상화(인터럽트가 불가능. 다만, 잠시 중단하거나 재진입 할 수 있는 여러 지점을 제공)
-   동시성이 코루틴의 속성은 아니다.
-   고루틴을 호스팅하는 Go의 메커니즘은 M:N 스켸쥴러를 구현한 것 (M개의 그린 스레드를 N개의 OS 스레드에 매핑)
-   Go는 fork-join 모델이라는 동시성 모델을 따름
-   고루틴은 자신이 생성된 곳과 동일한 주소 공간에서 실행됨
-   고루틴은 변수에 대한 참조가 이루어지는 경우 고루틴이 계속 변수에 접근할 수 있도록 메모리를 힙으로 이동시킴
-   이를 통해 개발자는 메모리 관리 대신 문제 공간에 집중할 수 있음(백지 수표는 아님)
-   고루틴은 매우 가벼움 (몇 kb)
-   Go의 GC는 고루틴을 회수하기 위해 어떠한 조치도 하지 않음
-   RAM이 1GB일 경우 고루틴은 약 371,800개 생성 가능
-   컨텍스트 스위칭 비용도 OS 컨텍스트 스위칭 대비 95% 빠름(예제의 고루틴 컨텍스트 스위칭 비용은 0.225um, OS 스위칭 비용은 1.467us)
-   Sync 패키지 -> 동기화에 유용한 패키지
-   Sync-WaitGroup : 동시에 수행된 연산의 결과를 신경쓰지 않거나, 결과를 수집할 다른 방법을 이용하는 경우 사용 (둘 다 충족하지 않으면 채널, select이용)
-   WaitGroup은 일종의 안전한 카운터, Add시 증가, Done시 감소
-   Sync-Mutex : 이미 잘 알려진데로 Mutual Exclusive를 의미. (이 경우 메모리 동기화는 개발자가 담당)
-   Sync-RWMutex: Read/Write에 대한 Mutex를 별도로 구현 (Reader가 256 이상일 때, 효과를 보임. 논리적으로 합당하다면 RWMutex 추천)

## Keyword

-   코루틴
-   그린 쓰레드
-   M:N 스켸쥴러
-   fork-join

# GO 동시성 프로그래밍, 2020-07-09, 86~100p

-   `Sync.Cond`패키지를 주로 설명함

-   `Cond`는 두 개 이상의 고루틴 사이에서 어떠한 이벤트가 발생했다는 정보를 전달함
-   나이브하게 쓰레드간 정보를 전달하기 위해 무한루프를 사용해서 전달함
-   이는 CPU 싸이클을 계속해서 사용하므로 비효율적
-   Sleep을 도모할 수 있지만, Sleep 주기를 계산해야함. 길면 부자연스럽고, 짧으면 CPU를 과도하게 사용
-   `Cond`는 고루틴을 `pause`하여 이러한 비효율을 극복함
-   `Cond` 에서 시그널을 보내는 방법은 `Signal`, `Broadcast` 가 있음
-   `Signal`은 가장 오래 기다린 고루틴을 찾아서 신호를 보냄
-   `Broadcast` 는 모든 고루틴에게 신호를 보냄. (모든 고루틴들과 한꺼번에 통신하는 기법으로 사용됨. ex) Pub-Sub)
-   `Cond`는 채널을 통해서 할 수 없는 것들을 할 수 있게 도와줌(`Broadcast`를 통해 )

-   `Once`는 특정 고루틴을 1회만 수행하게 함(1회만 수행하는 주체는 `Sync.Once.Do` 메소드 기준
-   예를들어 `var once Sync.Once`에서 `once.Do`(increment), `once.Do`(decrement) 로 사용되면 increment 한번만 수행 (`Sync.Once.Do` 가 한번만 호출됨을 의미)
-   따라서 이 두 함수를 각각 1회만 호출하고싶다면, `var A, B Sync.Once, A.Do(increment), B.Do(decrement)`형태로 사용해야함
-   `Once`는 Initialization에 사용될 수 있음
-   `Once` 를 잘못 사용하면 데드락이 발생할 수 있음 (책에서는 `Once`를 통해서 데드락이 발생하게끔 유도해 의도치 못한 버그를 찾아내라는 뉘앙스로 이야기하네요)

-   `Pool` 은 안전한 객체 풀 패턴 의 구현
-   `Pool` 없이 객체만 계속해서 생성하면 순간적으로 대용량의 메모리를 점유할 가능성이 있음
-   `Pool` 은 사전 로딩(캐싱) 방법을 통해 빠른 응답을 할 수 있게 사용할 수 있음(생성을 미리 해두고, 이를 사용하는 방식으로 응답시 생성비용을 지불하지 않게 할 수 있음)
-   다만 `Pool`에 있는 객체를 변경해야할 때는, Pool 을 사용하는게 더 비효율적일 수 있음. (객체 내 변수를 가변적으로 변경해야하는 경우)

## Keyword

-   객체 풀 패턴
-   쓰레드 간 정보 동기화 -> ex) spin lock

## Note

-   보면서 느껴지는게 Go runtime은 어떻게 보면 고루틴 스켸쥴러가 핵심이라는 느낌을 받습니다. 책이 동시성에 집중해서 설명해서 그런가..... Go의 기본 기능에서 고루틴을 스켸쥴링하는게 core logic처럼 느껴지네요

# GO 동시성 프로그래밍, 2020-07-16, 101~119p

-   채널은 고루틴 간에 정보를 전달할 때 가장 적합
-   값은 하류쪽에서 읽을 수 있으므로 채널 변수 이름은 `Stream`이라고 부르자(feat. 저자)
-   채널에 데이터를 보낼 때, 값을 `chan`변수에 전달한다.
-   채널에서 데이터를 읽을 때는 `chan`변수에서 읽어들인다.
-   채널은 단방향 데이터 흐름만 지원하도록 선언할 수도 있다.

```golang
var dataStream <- chan interface {}
dataStream := make(chan <- interface{})
```

-   단방향 채널은 함수의 매개변수나 리턴 타입으로 단방향 채널이 유용하게 사용될 수 있다.(??)
-   단방향으로 정의된 채널에 반대되는 방향의 데이터를 넣게되면 에러가 난다.(주의)
-   채널을 통해서 전달하는 데이터 타입은 `Any` 혹은 `특정한 타입의 데이터`를 주고받을 수 있다.
-   채널이 고루틴에 들어가있으면, 프로세스가 종료되기 전 고루틴 실행이 보장된다.
-   실행보장의 이유는 고루틴이 채널에서 데이터를 읽고 쓸 때, 데이터가 없으면 기다리고, 데이터가 있으면 비워질 때까지 기다리는 wait 메카니즘 덕분이다.
-   채널을 활용해서 읽기/쓰기 연산을 수행하는 고루틴의 경우 특정 조건에서 채널에 어떠한 작업도 하지 않고 종료하게되면 데드락이 발생할 수 있다. (아래 예제)

```golang
stringStream := make(chan string)
go func(){
	if 0 != 1{
		return
	}
	stringStream <- "Hello channels!"
}()
fmt.Println(<-stringStream)
```

-   위의 경우 `main 고루틴`에서는 채널에서 오는 데이터를 기다리고있는데, `익명 고루틴`은 종료되었기에 데드락이 발생한다.

*   `<-`의 수신 형식은 선택적으로 두 개의 값을 반환할 수 있다. `salutation, ok := <- stringStream`
*   `ok`는 `salutation`이 쓰기 연산을 통해 생성된 값인지 닫힌 채널에서 생성되는 기본 값인지를 나타내기 위해 사용한다.

-   닫힌채널은 프로그램에서 더 이상 값이 채널을 통해 전송되지 않는다는 것을 나타낸다. `close`키워드를 사용한다.
-   닫힌 채널은 수신하는 프로세스가 언제쯤 종료해야하는지 혹은 새로운 채널이나 다른 채널에서 통신을 열어야 할지 알 수 있게 도와준다.

```golang
valueStream := make(chan interface{})
close(valueStream)
```

-   닫힌 채널에서도 값을 읽을 수 있다. (쓰기는 안된다)

```golang
intStream := make(chan int)
close(intStream)
integer, ok := <- intStream
fmt.Printf("(%v): %v", ok, integer)
```

-   닫힌 채널은 채널이 닫히더라도 값을 계속 읽을 수 있다.
-   이는 채널의 데이터값을 읽는 하류의 고루틴이 채널이 닫히더라도 값을 읽기 위한 기능이다.(4장에서 이러한 상황이 일반적임을 보인다.)
-   위 예제에서 `ok`변수에 저장된 두 번째 리턴 값은 false이다. 이는 수신한 값이 정수형(`int`) `0`이거나 스트림에 값이 없다는 것을 의미한다.
-   채널을 닫는 것은 채널에서 데이터를 수신하려고 대기하는 여러 고루틴에 대기를 해제하는 효과가 있다. (N개의 종료 시그널을 보낼 필요가 없다.)

*   채널을 생성할 때, 기본 용량을 제공하는 버퍼링된 채널을 생성할 수 있다.
*   버퍼링된 채널은 채널에서 읽기가 전혀 수행되지 않더라도 고루틴이 n번의 쓰기를 수행할 수 있다.

```golang
var dataStream chan interface{}
dataStream = make(chan interface{}, 4)
```

-   버퍼링되지 않은 채널은 용량이 0으로 설정된 버퍼링된 채널과 같다.

```golang
var dataStream chan interface{}
dataStream = make(chan interface{})
// 서로 같다.
var dataStream chan interface{}
dataStream = make(chan interface{}, 0)
```

-   버퍼링된 채널에 버퍼가 가득차게 되었을 때, 쓰기연산을 수행하면 해당 고루틴은 대기하게된다.
-   버퍼링이된 채널이 비어 있는데 수신자가 있는 경우에는 버퍼가 무시되고 값이 송신자에서 수신자로 직접 전달된다.

*   버퍼링된 채널은 주의해서 만들어야한다. 버퍼링된 채널은 성급한 최적화가 되는 경우가 많으며 데드락을 숨긴다.(4장에서 설명한다.)
*   버퍼링된 채널을 디버깅하기 위해서 `stdoutBuffer`를 사용하면 좋다.

-   `nil` 채널에 읽기/쓰기/close를 하면 모두 panic에 빠진다.(읽기: 대기; deadlock, 쓰기: 대기; deadlock, close: panic)
-   채널을 올바르게 사용하기 위해서는 채널의 소유권을 할당해야한다.
-   책에서는 채널을 인스턴스화하고 쓰고 닫는 고루틴이 채널을 소유하고있다고 정의한다.
-   채널 소유자는 채널에 대해 1). 인스턴스화, 2). 소유권 이전 3).채널을 닫음 4). 읽기 채널을 통해 노출를 꼭 수행해야한다.
-   위의 책임을 채널 소유자에게 부여하면 1). 데드락 위험 방지, 2). nil 채널 닫기를 방지, 3). 닫힌 채널에 쓰는 연산 회피, 4). 채널을 두번 이상 닫는 위험(panic)을 피할 수 있다 와 같은 장점이 있다.
-   채널 소비자는 1). 채널이 닫히는 시점, 2). 대기가 발생하면 책임감 있게 처리 만 신경쓰면 된다.
-   첫번째 항을 위해;(1) 채널 소비자는 읽기 연산의 두번째 리턴값을 검사한다.(위예제에서 ok변수; `salutation, ok := <- stringStream`)
    두번째 항을 위한 내용은 4장에서 이야기한다.

-   채널 소유의 범위를 좁게 유지할 수 있도록 프로그램 상에서 할 수 있는 일은 하는 것이 좋다. 수많은 메소드가 있는 구조체의 멤버 변수인 채널이 있다면, 이 채널의 동작은 금세 불분명해진다.

## Note

-   이번 챕터 어렵네요. ㅎㅎ

# GO 동시성 프로그래밍, 2020-07-16, 119~126p

-   채널은 고루틴을 하나로 묶는 접착제
-   select문은 채널을 하나로 묶는 접착제
-   구성 요소들을 합치는 것 외에도, 프로그램상의 중요한 특정 시점에 select문을 사용해 취소, 시간 초과, 대기 및 기본값과 같은 개념을 안전하게 채널에 도입할 수있음

```golang
package main

func main() {
	var c1, c2 <-chan interface{}
	var c3 chan<- interface{}

	select {
	case <-c1:
		// 작업 수행

	case <-c2:
		// 작업 수행

	case c3 <- struct{}{}:
		// 작업 수행
	}
}
```

-   `select`문은 `switch` 블록처럼 보이나, `switch` 블록과 달리 `select`블록의 `case`문은 순차적으로 테스트되지 않으며, 조건이 하나도 충족되지 않으면 다음 조건으로 넘어가지 않는다.
-   `select` 블록은 채널 중 하나가 준비됐는지 확인하기 위해 모든 채널 읽기와 쓰기를 동시에 고려한다.
-   준비된 채널이 없는 경우 `select`문 전체가 중단돼 대기한다.(추후에 설명할 `default`문으로 이를 해결한다.)
-   그러면, 다음 사항에서는 `select`가 어떻게 작동하는지 확인해보자.(1. 여러 채널에 읽을 내용이 있을 경우, 2. 어떠한 채널도 준비되지 않은 경우, 3. 어떠한 작업을 하려고하지만, 준비된 채널이 없는 경우)

-   여러 채널에 읽을 내용이 있을 경우, 작업은 균등(uniform)하게 나누어져서 실행된다.

```golang
package main

import (
	"fmt"
)

func main() {
	c1 := make(chan interface{})
	close(c1)
	c2 := make(chan interface{})
	close(c2)

	var c1Count, c2Count int

	for i := 1000; i >= 0; i-- {
		select {
		case <-c1:
			c1Count++
		case <-c2:
			c2Count++
		}
	}
	fmt.Printf("c1Count: %d\nc2Count: %d\n", c1Count, c2Count)
}
```

```bash
$ go run main.go
>>>
c1Count: 490
c2Count: 511
```

-   Go의 runtime은 `case`구문의 집합에 대한 균일한 의사 무작위 선택을 수행
-   균일한 의사 무작위 선택을 하는 이유는 Go runtime은 `select`문의 의도에 대해서 알 수 없기 때문

-   준비된 채널이 없는 경우에는 영원히 대기한다. 이를 막기 위해서 timeout을 설정한다.

```golang
package main

import (
	"fmt"
	"time"
)

func main() {
	var c <-chan int
	select {
	case <-c:
	case <-time.After(1 * time.Second):
		fmt.Println("Time out.")
	}
}
```

```bash
$ go run main.go
>>> Time out.
```

-   어떠한 채널도 준비가 되지 않아을 때, 무엇을 해야하는가?... 선택하는 모든 채널이 차단되어 대기하는 경우를 대비해 Go는 `default`절을 허용한다.

```golang
package main

import (
	"fmt"
	"time"
)

func main() {
	start := time.Now()
	var c1, c2 <-chan int

	select {
	case <-c1:
	case <-c2:
	default:
		fmt.Printf("In default after %v\n\n", time.Since(start))
	}
}
```

```bash
$ go run main.go
>>> In default after 2.103µs
```

-   `default`절을 사용하면 기다리지 않고 `select`을 빠져나올 수 있다.
-   `select`문에 `case`절이 없는 경우에는 영원히 대기한다.

-   `GOMAXPROCS`함수는 **작업 대기열**이라고 불리는 OS 쓰레드의 수를 제어한다.
-   Go 1.5이전 버전에서는 `GOMAXPROCS`가 항상 1로 설정돼어있었다. 따라서 개발자들은 이 값을 변경해서 사용했다.

```golang
runtime.GOMAXPROCS(runtime.NumCPU())
```

-   GO 1.5버전 이후에는 자동으로 호스트 시스템의 논리적인 CPU수로 설정된다.
-   작업자 대기열 및 스레드 수를 늘리거나 줄인다고 해도 득보다 실이 더 클수 있지만, 충분히 유용하게 사용할 수 있다.
-   어쩐일인지 가끔씩 테스트에 실패하는 패키지가 몇개 있다고 가정하다. (데드락/라이브락/레이스 컨디션/기타 동시성 문제)
-   테스트를 실행한 인프라에는 논리적인 CPU가 4개 밖에 없다고 가정하자.
-   이때, `GOMAXPROCS`를 보유한 논리적 CPU수 이상으로 증가시켜서 훨씬 더 자주 동시성 문제를 유발시킬 수 있다.
-   이는, 문제를 신속하게 수정할 수 있게 해준다.
-   `GOMAXPROCS`를 수정해서 최적화된 프로그램은 모든 커밋을 할 때마다 사용하는 하드웨어나 Go의 버전에 맞춰 조정을 수행해야한다.(다른 환경에서는 문제가 생길 수 있음)
